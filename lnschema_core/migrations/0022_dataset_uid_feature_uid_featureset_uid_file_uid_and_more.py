# Generated by Django 4.2.5 on 2023-10-08 03:00

import importlib
from typing import Dict, Union

from django.db import migrations, models
from lamindb_setup import settings as _settings
from lamindb_setup._init_instance import get_schema_module_name

import lnschema_core.ids  # noqa
from lnschema_core.models import LinkORM


class SchemaMetadata:
    _models: Union[dict[str, dict[str, "ModelMetadata"]], None] = None

    @staticmethod
    def get_models():
        if SchemaMetadata._models is None:
            SchemaMetadata._models = get_models_metadata()
        return SchemaMetadata._models


class ModelMetadata:
    def __init__(self, model) -> None:
        self.model = model
        self.class_name = model.__name__
        self.model_name = model._meta.model_name
        self.relations = ModelRelations(model)
        self.fields_metadata = get_fields_metadata(self.model)


class ModelRelations:
    def __init__(self, model) -> None:
        self.many_to_one = {}
        self.one_to_many = {}
        self.many_to_many = {}
        self.one_to_one = {}

        for field in model._meta.get_fields():
            if field.many_to_one:
                self.many_to_one.update({field.name: field})
            elif field.one_to_many:
                self.one_to_many.update({field.name: field})
            elif field.many_to_many:
                self.many_to_many.update({field.name: field})
            elif field.one_to_one:
                self.one_to_one.update({field.name: field})

        self.all = {
            **self.many_to_one,
            **self.one_to_many,
            **self.many_to_many,
            **self.one_to_one,
        }


def get_fields_metadata(model):
    fields = {}

    for field in model._meta.fields:
        fields.update({field.name: get_field_metadata(model, field)})

    model_relations_metadata = ModelRelations(model)

    # One to many

    for relation_name, relation in model_relations_metadata.one_to_many.items():
        fields.update({f"{relation_name}": get_field_metadata(model, relation.field)})

    # Many to many

    for link_field_name, link_field in model_relations_metadata.many_to_many.items():
        fields.update({f"{link_field_name}": get_field_metadata(model, link_field)})

    # Many to one

    for link_field_name, link_field in model_relations_metadata.many_to_one.items():
        fields.update({f"{link_field_name}": get_field_metadata(model, link_field)})

    for link_field_name, link_field in model_relations_metadata.many_to_one.items():
        for field in link_field.related_model._meta.fields:
            fields.update({f"{link_field_name}__{field.name}": get_field_metadata(model, field)})

    # One to one

    for link_field_name, link_field in model_relations_metadata.one_to_one.items():
        fields.update({f"{link_field_name}": get_field_metadata(model, link_field)})

    for link_field_name, link_field in model_relations_metadata.one_to_one.items():
        for field in link_field.related_model._meta.fields:
            fields.update({f"{link_field_name}__{field.name}": get_field_metadata(model, field)})

    return fields


def get_field_metadata(model, field):
    internal_type = field.get_internal_type()
    model_name = field.model.__name__
    relation_type = get_relation_type(model, field)
    if field.related_model:
        related_model_name = field.related_model.__name__
        if relation_type == "one-to-many":
            related_schema_name = field.model._meta.app_label.replace("lnschema_", "")
            schema_name = field.related_model._meta.app_label.replace("lnschema_", "")
            related_field_name = field.name
            field_name = field.remote_field.name
        else:
            related_schema_name = field.related_model._meta.app_label.replace("lnschema_", "")
            schema_name = field.model._meta.app_label.replace("lnschema_", "")
            related_field_name = field.remote_field.name
            field_name = field.name
    else:
        schema_name = field.model._meta.app_label.replace("lnschema_", "")
        related_model_name = None
        related_schema_name = None
        related_field_name = None
        field_name = field.name

    if relation_type in ["one-to-many"]:
        model_name, related_model_name = related_model_name, model_name

    if relation_type in ["many-to-many", "one-to-one"]:
        column = None
    else:
        column = field.column

    return {
        "schema_name": schema_name,
        "related_schema_name": related_schema_name,
        "model_name": model_name,
        "related_model_name": related_model_name,
        "field_name": field_name,
        "related_field_name": related_field_name,
        "column": column,
        "type": internal_type,
        "relation_type": relation_type,
        "is_link_table": issubclass(field.model, LinkORM),
    }


def get_relation_type(model, field):
    if field.many_to_one:
        if model == field.model:
            return "many-to-one"
        else:
            return "one-to-many"
    elif field.one_to_many:
        return "one-to-many"
    elif field.many_to_many:
        return "many-to-many"
    elif field.one_to_one:
        return "one-to-one"
    else:
        return None


def get_queryable_field_names(model):
    fields = [field for field in model._meta.fields]
    model_relations_metadata = ModelRelations(model)

    for link_field_name, link_field in model_relations_metadata.many_to_one.items():
        fields.extend([f"{link_field_name}__{field.name}" for field in link_field.related_model._meta.fields])

    return fields


def get_selectable_field_names(model):
    fields = get_queryable_field_names(model)
    model_relations_metadata = ModelRelations(model)

    for link_field_name, link_field in model_relations_metadata.one_to_many.items():
        fields.extend([f"{link_field_name}__{field.name}" for field in link_field.related_model._meta.fields])

    return fields


def get_models_metadata():
    schema_names = ["core"] + list(_settings.instance.schema)
    metadata: Dict[str, Dict[str, ModelMetadata]] = {}
    for schema_name in schema_names:
        schema_module = importlib.import_module(f"{get_schema_module_name(schema_name)}.models")
        metadata[schema_name] = {}
        for model in schema_module.__dict__.values():
            if model.__class__.__name__ == "ModelBase" and model.__name__ not in [
                "Registry",
                "ORM",
            ]:
                metadata[schema_name].update({model.__name__: ModelMetadata(model)})
    return metadata


CORE_MODELS = {
    "Dataset": False,
    "File": False,
    "Transform": False,
    "Run": True,
    "User": False,
    "Storage": False,
    "Feature": False,
    "FeatureSet": False,
    "Modality": False,
    "ULabel": False,
}


def create_new_ids(apps, schema_editor):
    global ID_MAPPER

    for model_name in CORE_MODELS.keys():
        # print(f"creating new id column for {model_name}")
        model_class = apps.get_model("lnschema_core", model_name)
        new_id = 1
        for record in model_class.objects.all().iterator(chunk_size=50):
            record.id = new_id
            record.save()
            new_id += 1


class Migration(migrations.Migration):
    dependencies = [
        ("lnschema_core", "0021_dataset_storage_alter_dataset_file"),
    ]

    operations = []  # type: ignore


# repurpose old primary key
for model_name in CORE_MODELS.keys():
    Migration.operations.append(
        migrations.RenameField(
            model_name=model_name,
            old_name="id",
            new_name="uid",
        )
    )


# add new primary key field
for model_name, big in CORE_MODELS.items():
    Migration.operations.append(
        migrations.AddField(
            model_name=model_name,
            name="id",
            field=models.BigIntegerField(editable=False, null=True) if big else models.IntegerField(editable=False, null=True),
            preserve_default=False,
        )
    )

# fill in new id values in entity tables
Migration.operations.append(migrations.RunPython(create_new_ids, reverse_code=migrations.RunPython.noop))


# make them unique
for model_name, big in CORE_MODELS.items():
    Migration.operations.append(
        migrations.AlterField(
            model_name=model_name,
            name="id",
            field=models.BigIntegerField(editable=False, unique=True) if big else models.IntegerField(editable=False, unique=True),
            preserve_default=False,
        )
    )


def add_a_tmp_column_foreign_keys(model_name):
    # print(f"creating tmp foreign key column for {model_name}")
    model_metadata = SchemaMetadata.get_models()["core"][model_name]
    # for each many_to_many, loop through foreign keys
    # for many_to_many_field in model_metadata.relations.many_to_many:
    #     add_a_new_column_foreign_keys(many_to_many_field.model)
    # for each foreign_key, add a new column with _tmp suffix
    migrations_list = []
    # fields_metadata = model_metadata.fields_metadata
    for foreign_key_name in model_metadata.relations.many_to_one:
        command = f"ALTER TABLE {model_metadata.model._meta.db_table} ADD {foreign_key_name}_id_tmp2 int"
        migrations_list.append(migrations.RunSQL(command))
    return migrations_list


# add temporary ID fields
for model_name in CORE_MODELS.keys():
    Migration.operations += add_a_tmp_column_foreign_keys(model_name=model_name)


def populate_tmp_column_foreign_keys(model_name):
    # print(f"populate tmp foreign key column for {model_name}")
    model_metadata = SchemaMetadata.get_models()["core"][model_name]
    migrations_list = []
    for foreign_key_name in model_metadata.relations.many_to_one:
        related_model = model_metadata.model._meta.get_field(foreign_key_name).related_model
        table = model_metadata.model._meta.db_table
        related_table = related_model._meta.db_table
        command = f"UPDATE {table} SET {foreign_key_name}_id_tmp2=(SELECT id FROM {related_table} WHERE {table}.{foreign_key_name}_id={related_table}.uid)"
        migrations_list.append(migrations.RunSQL(command))
    return migrations_list


# populate temporary fields
for model_name in CORE_MODELS.keys():
    Migration.operations += populate_tmp_column_foreign_keys(model_name=model_name)


def delete_old_foreign_keys(model_name):
    print(f"deleting old foreign key columns for {model_name}")
    model_metadata = SchemaMetadata.get_models()["core"][model_name]
    # for each many_to_many, loop through foreign keys
    # for many_to_many_field in model_metadata.relations.many_to_many:
    #     add_a_new_column_foreign_keys(many_to_many_field.model)
    # for each foreign_key, add a new column with _tmp suffix
    migrations_list = []
    for foreign_key_name in model_metadata.relations.many_to_one:
        if not (model_name == "File" and foreign_key_name == "storage"):
            migrations_list.append(migrations.RemoveField(model_name, foreign_key_name))
    return migrations_list


# delete old foreign keys
for model_name in CORE_MODELS.keys():
    Migration.operations += delete_old_foreign_keys(model_name=model_name)
